# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T10:33:17+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyQuery, BaseSecurity
from fastapi import Path, Query
from pydantic import conint, constr

from models import (
    Format,
    Format4,
    Format6,
    Format7,
    Layer,
    Layers,
    Request,
    Request2,
    Service,
    Srs,
    Style,
    Style2,
    Style3,
    Styles,
    TileSize,
    Version,
    VersionNumber,
    View,
    View2,
    View4,
    WmtsVersion,
    Zoom,
    Zoom1,
)

app = MCPProxy(
    contact={'x-twitter': 'TomTom'},
    description='The Maps API web services suite offers the following APIs:\n  - Raster\n  The Maps Raster API renders map data that is divided into gridded sections called tiles. Tiles are square images (png or jpg format) in various sizes which are available at 19 different zoom levels, ranging from 0 to 20. For zoom level 0, the entire earth is displayed on one single tile, while at zoom level 20, the world is divided into 2<sup>40</sup> tiles.\n  - Vector\n  Similar to Maps Raster API, the Maps Vector API serves data on different zoom level ranging from 0 to 22. For zoom level 0, the entire earth is displayed on one single tile, while at zoom level 22, the world is divided into 2<sup>44</sup> tiles.\n  The Maps Vector Service delivers geographic map data packaged in a vector representation of squared sections called vector tiles. Each tile includes pre-defined collections of map features (points, lines, road shapes, water polygons, building footprints, ect.) delivered in one of the specified vector formats. Format of the tile is formally described using protobuf schema.',
    title='Maps',
    version='1.0.0',
    servers=[{'url': 'https://api.tomtom.com'}],
)


@app.get(
    '/map/{versionNumber}/copyrights.{format}',
    description=""" The Copyrights API returns copyright information for
the Maps API Raster Tile Service in JSON, JSONP, or XML format.
This call returns copyright information for the whole world. """,
    tags=['map_copyright_management', 'map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_map__version_number_copyrights__format(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    format: Format = 'xml',
    callback: Optional[str] = None,
):
    """
    Copyrights whole world
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/copyrights/caption.{format}',
    description=""" This API returns copyright captions for the map service. """,
    tags=['map_copyright_management', 'map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_map__version_number_copyrights_caption__format(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    format: Format = 'xml',
    callback: Optional[str] = None,
):
    """
    Captions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/copyrights/{minLon}/{minLat}/{maxLon}/{maxLat}.{format}',
    description=""" The Copyrights API returns copyright information for
the Maps API Raster Tile Service in JSON, JSONP, or XML format.
This call returns copyright information for a specific bounding box. """,
    tags=['map_copyright_management', 'map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_copyrights_bounding_box(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    format: Format = 'xml',
    min_lon: float = Path(..., alias='minLon'),
    min_lat: float = Path(..., alias='minLat'),
    max_lon: float = Path(..., alias='maxLon'),
    max_lat: float = Path(..., alias='maxLat'),
    callback: Optional[str] = None,
):
    """
    Copyrights bounding box
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/copyrights/{zoom}/{X}/{Y}.{format}',
    description=""" The Copyrights API returns copyright information for
the Maps API Raster Tile Service in JSON, JSONP, or XML format.
This call returns copyright information for the a specific map tile. """,
    tags=['map_copyright_management', 'map_tile_retrieval', 'map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_map__version_number_copyrights__zoom___x___y__format(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    format: Format = 'xml',
    zoom: Zoom = ...,
    x: int = Path(..., alias='X'),
    y: int = Path(..., alias='Y'),
    callback: Optional[str] = None,
):
    """
    Copyrights tile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/staticimage',
    description=""" The Static Image service renders a rectangular raster image
in the style, size, and zoom level specified. The image can be requested
using either a center point plus width and height or a bounding box. """,
    tags=['map_tile_retrieval', 'map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_map__version_number_staticimage(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    layer: Optional[Layer] = 'basic',
    style: Optional[Style] = 'main',
    format: Optional[Format4] = 'png',
    zoom: Optional[Zoom1] = 12,
    center: Optional[constr(pattern=r'^-*\d+\.*\d*, *-*\d+\.*\d*$')] = None,
    width: Optional[conint(ge=1, le=8192)] = 512,
    height: Optional[conint(ge=1, le=8192)] = 512,
    bbox: Optional[constr(pattern=r'^(-*\d+\.*\d*,){3}(-*\d+\.*\d*)$')] = None,
    view: Optional[View] = None,
):
    """
    Static Image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/tile/{layer}/{style}/{zoom}/{X}/{Y}.pbf',
    description=""" The Maps API Vector Service delivers vector tiles, which are representations of square sections of map data. """,
    tags=['map_tile_retrieval', 'map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_map__version_number_tile__layer__style__zoom___x___y_pbf(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    layer: Layer = ...,
    style: Style2 = ...,
    zoom: Zoom1 = ...,
    x: int = Path(..., alias='X'),
    y: int = Path(..., alias='Y'),
    view: Optional[View2] = None,
    language: Optional[str] = 'NGT',
):
    """
    Tile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/tile/{layer}/{style}/{zoom}/{X}/{Y}.{format}',
    description=""" The Maps API Raster Service delivers raster tiles, which are representations of square sections of map data. """,
    tags=['map_tile_retrieval', 'map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_map__version_number_tile__layer__style__zoom___x___y__format(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    layer: Layer = ...,
    style: Style3 = ...,
    zoom: Zoom1 = ...,
    x: int = Path(..., alias='X'),
    y: int = Path(..., alias='Y'),
    format: Format6 = ...,
    tile_size: Optional[TileSize] = Query(256, alias='tileSize'),
    view: Optional[View4] = None,
):
    """
    Tile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/wms/',
    description=""" The GetMap call implements the Web Map Service 1.1.1 standard
to access TomTom raster map tiles. This service is described
in the response to the GetCapabilities API call. """,
    tags=['map_tile_retrieval', 'map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_map(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    request: Request = ...,
    srs: Srs = ...,
    bbox: constr(pattern=r'^(-*\d+\.*\d*, *){3}(-*\d+\.*\d*)$') = ...,
    width: int = ...,
    height: int = ...,
    format: Format7 = ...,
    layers: Layers = ...,
    styles: Optional[Styles] = None,
    service: Optional[Service] = None,
    version: Version = ...,
):
    """
    GetMap
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/wms//',
    description=""" The GetCapabilities call is part of TomTom's implementation of version 1.1.1
the Web Map Service (WMS). It provides descriptions of the other calls
that are available in the implementation. """,
    tags=['map_service_interactions'],
    security=[
        APIKeyQuery(name="key"),
    ],
)
def get_capabilities(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    service: Service = ...,
    request: Request2 = ...,
    version: Optional[Version] = None,
):
    """
    GetCapabilities
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/map/{versionNumber}/wmts/{key}/{wmtsVersion}/WMTSCapabilities.xml',
    description=""" The WMTS GetCapabilities call implements version 1.0.0 of
the <a href="http://www.opengeospatial.org/standards/wmts">Web Map Tile Service</a>
(WMTS) standard. It returns metadata that allows compatible calling systems to construct
calls to TomTom's raster map tile service. See the
<a href="/maps-api/maps-api-documentation-raster/wmts">documentation</a>
for more information on WMTS. """,
    tags=['map_service_interactions', 'map_tile_retrieval'],
)
def retrieve_wmts_version_info(
    version_number: VersionNumber = Path(..., alias='versionNumber'),
    key: str = ...,
    wmts_version: WmtsVersion = Path(..., alias='wmtsVersion'),
):
    """
    WMTS
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
